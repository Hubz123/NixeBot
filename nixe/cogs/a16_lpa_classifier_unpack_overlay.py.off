# -*- coding: utf-8 -*-
"""
a16_lpa_classifier_unpack_overlay
---------------------------------
Non-invasive hotfix that NORMALIZES the return from gemini_bridge.classify_lucky_pull_bytes
so lucky_pull_auto never crashes with:
  ValueError('too many values to unpack (expected 2)')

- Does NOT change configs, env, or templates.
- Works regardless of whether the original code expects 2/3/4-tuple or dict.
- Applies at runtime by monkey-patching LuckyPullAuto._classify().
"""
from __future__ import annotations

import asyncio
import logging
from typing import Any, Tuple

log = logging.getLogger(__name__)

def _provider_threshold(provider: str) -> float:
    import os
    try: eps = float(os.getenv("LPG_CONF_EPSILON") or 0.0)
    except Exception: eps = 0.0
    if provider and str(provider).lower().startswith("gemini"):
        try: thr = float(os.getenv("GEMINI_LUCKY_THRESHOLD") or os.getenv("LPG_GEMINI_THRESHOLD") or 0.85)
        except Exception: thr = 0.85
        return max(0.0, min(1.0, thr - eps))
    try: thr = float(os.getenv("LPG_GROQ_THRESHOLD") or 0.50)
    except Exception: thr = 0.50
    return max(0.0, min(1.0, thr - eps))

def _normalize(res: Any) -> Tuple[bool, float, str, str]:
    """Return (ok, score, provider, reason) for any common shape."""
    ok=False; score=0.0; provider="unknown"; reason=""
    # dict
    if isinstance(res, dict):
        score = float(res.get("score") or res.get("prob") or res.get("p") or 0.0)
        provider = str(res.get("provider") or res.get("via") or "unknown")
        reason = str(res.get("reason") or "")
        ok = bool(res.get("ok")) if "ok" in res else (score >= _provider_threshold(provider))
        return ok, score, provider, reason
    # tuple/list
    if isinstance(res, (list, tuple)):
        n = len(res)
        if n >= 4:
            ok, score, provider, reason = res[0], float(res[1]), str(res[2]), str(res[3])
            return bool(ok), float(score), provider, reason
        if n == 3:
            score, provider, reason = float(res[0]), str(res[1]), str(res[2])
            return score >= _provider_threshold(provider), score, provider, reason
        if n == 2:
            score, provider = float(res[0]), str(res[1])
            return score >= _provider_threshold(provider), score, provider, ""
        if n == 1:
            score = float(res[0])
            return score >= _provider_threshold("unknown"), score, "unknown", ""
    # single numeric
    try:
        score = float(res)
        return score >= _provider_threshold("unknown"), score, "unknown", ""
    except Exception:
        pass
    return False, 0.0, "unknown", "invalid_result"

async def setup(bot):
    # Import targets lazily to avoid hard dependency on order
    try:
        from nixe.cogs import lucky_pull_auto as _lpa
    except Exception as e:
        log.warning("[lpa-unpack] lucky_pull_auto not available: %r", e)
        return

    # get bridge
    try:
        from nixe.helpers.gemini_bridge import classify_lucky_pull_bytes as _bridge
    except Exception as e:
        _bridge = None
        log.warning("[lpa-unpack] gemini bridge not available: %r", e)

    # If target class not present, bail quietly
    if not hasattr(_lpa, "LuckyPullAuto"):
        log.warning("[lpa-unpack] LuckyPullAuto class not found; no patch applied")
        return

    async def _patched_classify(self, img_bytes: bytes, *, text: str = ""):
        """Unified classifier that never raises unpack errors."""
        if _bridge is None:
            return False, 0.0, "none", "classifier_unavailable"
        loop = asyncio.get_running_loop()
        try:
            def _call():
                # mirror common signature; tolerate absence of attributes
                timeout_ms = getattr(self, "timeout_ms", 20000)
                providers = getattr(self, "providers", None)
                return _bridge(img_bytes, text=text, timeout_ms=timeout_ms, providers=providers)
            res = await loop.run_in_executor(None, _call)
        except Exception as e:
            log.warning("[lpa-unpack] bridge call failed: %r", e)
            return False, 0.0, "none", "exception"
        try:
            ok, score, provider, reason = _normalize(res)
            return ok, score, provider, reason
        except Exception as e:
            log.warning("[lpa-unpack] normalize failed: %r (res=%r)", e, res)
            return False, 0.0, "none", "normalize_exception"

    # Monkey-patch
    try:
        _lpa.LuckyPullAuto._classify = _patched_classify  # type: ignore[attr-defined]
        log.warning("[lpa-unpack] Applied normalize patch to LuckyPullAuto._classify")
    except Exception as e:
        log.warning("[lpa-unpack] Failed to patch LuckyPullAuto._classify: %r", e)
